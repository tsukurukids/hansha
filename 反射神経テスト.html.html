<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>反射神経テスト</title>
    <!-- Tailwind CSS CDN --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* カスタムスタイル */
        :root {
            --nightmare-go-color: #4d6b1d; /* 黄色寄りの暗い緑色 */
        }
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.4s ease; /* 色の変化を滑らかに */
            position: relative; 
        }
        .text-shadow {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        /* ホーム画面コンテナのスタイル */
        #home-screen {
            background-color: rgba(23, 37, 84, 0.85); /* blue-900の少し透明な色 */
            z-index: 10;
        }

        /* レインボーモードのアニメーション */
        @keyframes rainbow-bg {
            0% { background-color: #f00; } /* 赤 */
            16% { background-color: #ff0; } /* 黄 */
            33% { background-color: #0f0; } /* 緑 */
            50% { background-color: #0ff; } /* シアン */
            66% { background-color: #00f; } /* 青 */
            83% { background-color: #f0f; } /* マゼンタ */
            100% { background-color: #f00; } /* 赤に戻る */
        }
        .rainbow-mode {
            animation: rainbow-bg 3s linear infinite; /* 3秒かけて繰り返し変化 */
            transition: none; /* レインボー中は通常のトランジションを無効化 */
        }

        /* パーティーテキストのアニメーション */
        @keyframes flow-in {
            0% { transform: translate(100%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, 0%) scale(1.2); opacity: 0.8; }
            100% { transform: translate(-200%, 50%) scale(0.8); opacity: 0; }
        }

        .party-text {
            position: absolute;
            font-size: 8vw; /* Large size */
            color: white;
            opacity: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            pointer-events: none; /* クリックをブロックしない */
            animation: flow-in 6s ease-in-out 0s infinite alternate; /* デフォルトアニメーション */
        }

        /* ゴーストモードのオーバーレイテキスト */
        .ghost-overlay-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 1; /* メッセージよりも下に配置 */
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-content: space-around;
            opacity: 0.1; /* 薄くする */
            color: #ccc; /* 薄い灰色 */
            font-size: 4vw;
            font-weight: bold;
            line-height: 1.5;
            padding: 10%;
            text-align: center;
            transform: rotate(-15deg); /* 斜めに流す */
        }
        .ghost-text-item {
            user-select: none;
            white-space: nowrap;
            display: inline-block;
            margin: 10px 20px;
            animation: pulse-opacity 5s infinite alternate;
        }
        @keyframes pulse-opacity {
            0% { opacity: 0.7; }
            100% { opacity: 0.9; }
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="game-container" class="bg-blue-600" onclick="handleMouseClick()">
        
        <!-- === ゴーストモード オーバーレイテキスト (NEW) === -->
        <div id="ghost-text-overlay" class="ghost-overlay-text hidden">
            <!-- JavaScriptでテキストが生成されます -->
        </div>
        <!-- ============================================== -->

        <!-- === ホーム画面コンテナ (最初/最終結果後に表示) --><div id="home-screen" class="absolute inset-0 flex flex-col justify-center items-center p-8 hidden">
            <h2 class="text-white text-5xl md:text-7xl font-extrabold text-shadow mb-8">反射神経テスト</h2>
            
            <!-- 難易度設定 --><div class="mb-12 flex flex-col items-center p-6 bg-black/30 rounded-xl shadow-2xl">
                <label for="difficulty-select" class="text-white text-lg font-semibold block mb-2 text-shadow">難易度を選択:</label>
                <select id="difficulty-select" 
                        class="p-3 rounded-lg bg-black/50 text-white text-lg border border-gray-500 focus:outline-none focus:ring-4 focus:ring-yellow-400 cursor-pointer shadow-lg"
                        onchange="setDifficulty(this.value)">
                    <option value="easy">簡単 (2.0秒 - 5.0秒)</option>
                    <option value="normal" selected>普通 (1.0秒 - 5.0秒)</option>
                    <option value="hard">難しい (0.5秒 - 3.0秒 + 30%フェイント)</option>
                    <option value="nightmare">ナイトメア (1秒 - 30秒 + 55%フェイント)</option>
                    <option value="ghost">ゴースト (1秒 - 1.5秒 + 96.0111111111%フェイント)</option>
                </select>
            </div>

            <!-- 開始ボタン --><button id="start-button" 
                    onclick="event.stopPropagation(); handleStartClick();"
                    class="p-4 px-12 bg-green-500 hover:bg-green-600 text-white text-3xl font-bold rounded-xl shadow-2xl transition duration-200 transform hover:scale-105">
                開始
            </button>
        </div>
        <!-- ============================================== --><!-- 統計情報と結果を表示するコンテナ (上部) --><div id="stats-container" class="absolute top-0 w-full p-4 text-center text-white text-lg md:text-xl font-semibold bg-black bg-opacity-30 rounded-b-xl shadow-lg transition duration-400">
            <!-- JavaScriptで内容が更新されます --></div>

        <!-- 過去の平均記録を表示するコンテナ (右下) --><div id="history-container" 
             class="absolute bottom-[72px] right-4 w-[280px] transition-all duration-300 ease-out transform translate-x-full z-10">
            <!-- JavaScriptで内容が更新されます --></div>
        
        <!-- 履歴トグルボタン (右下) --><button id="toggle-history-button" 
                onclick="event.stopPropagation(); toggleHistory();"
                class="absolute bottom-4 right-4 p-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition duration-300 z-20 flex items-center space-x-2 hidden">
            <!-- JavaScriptで内容が更新されます --></button>
        
        <!-- メインゲームメッセージ (ホーム画面では非表示) --><div id="main-message" class="text-white text-5xl md:text-7xl font-extrabold text-shadow transition duration-300 transform scale-100 hidden">
            反射神経テスト
        </div>
        <div id="sub-message" class="text-white text-xl md:text-2xl mt-4 text-shadow transition duration-300 hidden">
            クリックして開始
        </div>
    </div>

    <script>
        // グローバル変数
        const gameContainer = document.getElementById('game-container');
        const mainMessage = document.getElementById('main-message');
        const subMessage = document.getElementById('sub-message');
        const statsContainer = document.getElementById('stats-container'); 
        const historyContainer = document.getElementById('history-container'); 
        const toggleButton = document.getElementById('toggle-history-button'); 
        const homeScreen = document.getElementById('home-screen'); // NEW: ホーム画面コンテナ
        const difficultySelect = document.getElementById('difficulty-select');
        const ghostTextOverlay = document.getElementById('ghost-text-overlay'); // NEW: ゴーストオーバーレイ

        // ゲームの状態: 'home', 'waiting', 'pre-alert', 'go', 'feint', 'finished', 'rainbow', 'party' (NEW)
        let gameState = 'home'; // 初期状態を 'home' に変更
        let startTime = 0;
        let timeoutId = null;
        let preAlertTimeoutId = null; // 準備メッセージ用のタイマーID
        let rainbowTimeoutId = null; // レインボー効果用のタイマーID
        let partyTimeoutId = null; // NEW: パーティー効果用のタイマーID
        let partyElements = []; // NEW: パーティーテキスト要素を保持する配列
        
        // 3回平均のための変数
        let reactionTimes = []; // 結果を保持する配列 (個別の3回の記録)
        let attemptCount = 0;   // 現在の試行回数 (成功したクリックまたはペナルティの試行)
        const maxAttempts = 3;  // 最大試行回数
        const apiKey = ""; 

        // === [履歴開閉の状態] ===
        let historyIsOpen = false; // 初期状態: 閉じる
        let currentHistoryView = 'normal'; // 現在表示している履歴の難易度
        
        // === [ペナルティ定数の追加] ===
        const STANDARD_FAILURE_PENALTY_MS = 500; // 標準の失敗時間
        const USER_REQUESTED_PENALTY_MS = 10;     // ユーザーが要求した追加ペナルティ
        const TOTAL_FEINT_PENALTY = STANDARD_FAILURE_PENALTY_MS + USER_REQUESTED_PENALTY_MS; // 510ms

        // === [煽りメッセージのしきい値] ===
        const TAUNT_THRESHOLD_MS = 350; 
        const OKAY_THRESHOLD_MS = 300; 
        const EXCELLENT_THRESHOLD_MS = 200; 
        
        // === [最終平均のしきい値] ===
        const AVERAGE_PRO_MAX = 249; // プロゲーマーの域 (249ms 以下)
        const AVERAGE_WORST_MIN = 401; // 401ms 以上
        const AVERAGE_NORMAL_MIN = 300; 
        const AVERAGE_NORMAL_MAX = 400; 
        const AVERAGE_GOOD_MIN = 250; 
        const AVERAGE_GOOD_MAX = 299; 
        // === [ゴースト専用のしきい値] ===
        const GHOST_EXCELLENT_MAX = 300; // 300ms 以下で特別メッセージ
        // ============================
        
        // === [難易度設定の定義] ===
        let currentDifficulty = 'normal'; 
        const difficultySettings = {
            // min, max: GOサインまでのランダムな遅延時間 (ms)
            // feintChance: フェイントが発生する確率 (0.0 - 1.0)
            easy: { min: 2000, max: 5000, feintChance: 0 },
            normal: { min: 1000, max: 5000, feintChance: 0.015 }, // 1.5% の確率でフェイントを追加
            hard: { min: 500, max: 3000, feintChance: 0.3 }, // 30%の確率でフェイント発生
            // ナイトメアの妨害確率はそのまま維持 (以前の設定: rainbow 0.30, party 0.35)
            nightmare: { min: 1000, max: 30000, feintChance: 0.55, rainbowChance: 0.30, partyChance: 0.35 }, 
            // ゴーストの妨害確率を 0 に修正
            // 95.9% + 0.1111111111% = 0.960111111111
            ghost: { min: 1000, max: 1500, feintChance: 0.960111111111, rainbowChance: 0, partyChance: 0 } 
        };
        const allDifficulties = {
            'easy': '簡単',
            'normal': '普通',
            'hard': '難しい',
            'nightmare': 'ナイトメア', // NEW: ナイトメアモード
            'ghost': 'ゴースト' // NEW: ゴーストモード
        };
        
        // === [ゴーストオーバーレイテキストの設定] ===
        const GHOST_TEXT = '君はこれを平均３００msでクリアできるのか…';
        const GHOST_TEXT_REPEAT = 25; // 表示するテキストの数
        // ============================================


        /**
         * 選択された難易度をグローバル変数に設定する
         * @param {string} level - 選択された難易度 ('easy', 'normal', 'hard')
         */
        function setDifficulty(level) {
            currentDifficulty = level;
            console.log(`難易度を ${level} に設定しました。`);
            // UIがゲーム中の場合は難易度変更を待機する
            updateStats(); // 難易度表示の更新
        }
        
        /**
         * 履歴リストの表示難易度を切り替える
         * @param {string} difficulty - 表示する難易度
         */
        function setCurrentHistoryView(difficulty) {
            currentHistoryView = difficulty;
            updateHistoryList();
        }

        /**
         * 難易度を指定してlocalStorageから過去の平均記録の配列を取得する
         * @param {string} difficulty - 難易度キー
         * @returns {number[]} 過去の平均スコアの配列
         */
        function getScoreHistoryByDifficulty(difficulty) {
            const historyJson = localStorage.getItem(`scoreHistory_${difficulty}`);
            return historyJson ? JSON.parse(historyJson) : [];
        }

        /**
         * 難易度を指定して過去の平均記録の配列をlocalStorageに保存する
         * @param {string} difficulty - 難易度キー
         * @param {number[]} history - 保存する平均スコアの配列
         */
        function saveScoreHistoryByDifficulty(difficulty, history) {
            localStorage.setItem(`scoreHistory_${difficulty}`, JSON.stringify(history));
        }

        /**
         * 新しい平均スコアを履歴に追加し、最大5件に制限して保存する
         * 現在の難易度を使用する。
         * @param {number} newScore - 新しい平均スコア
         */
        function addScoreToHistory(newScore) {
            const history = getScoreHistoryByDifficulty(currentDifficulty);
            // 新しいスコアを配列の先頭に追加
            history.unshift(newScore); 
            // 最新の5件のみを保持
            const limitedHistory = history.slice(0, 5);
            saveScoreHistoryByDifficulty(currentDifficulty, limitedHistory);
        }

        /**
         * ベスト記録（High Score）を取得し、表示用の文字列を返す
         * 現在の難易度を使用する。
         */
        function getHighScoreDisplay() {
            // localStorageからベストスコアを取得。数値が小さいほど良いスコア
            const currentHighScore = localStorage.getItem(`highScore_${currentDifficulty}`);
            return currentHighScore && currentHighScore !== 'Infinity' 
                ? `${currentHighScore} ms` : `未登録`;
        }
        
        /**
         * 履歴リストの開閉を切り替える
         */
        function toggleHistory() {
            // 履歴ボタンが非表示の場合は何もしない
            if (toggleButton.classList.contains('hidden')) return;

            historyIsOpen = !historyIsOpen;
            
            if (historyIsOpen) {
                // 開く
                historyContainer.classList.remove('translate-x-full');
                historyContainer.classList.add('translate-x-0');
                // アイコン: 上向き矢印
                toggleButton.innerHTML = `記録を閉じる <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd" /></svg>`; 
            } else {
                // 閉じる
                historyContainer.classList.remove('translate-x-0');
                historyContainer.classList.add('translate-x-full');
                // アイコン: 下向き矢印
                toggleButton.innerHTML = `過去の記録 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>`;
            }
        }

        /**
         * ゴーストテキストオーバーレイを初期化する
         */
        function initializeGhostOverlay() {
            if (ghostTextOverlay.children.length === 0) {
                let htmlContent = '';
                for (let i = 0; i < GHOST_TEXT_REPEAT; i++) {
                    htmlContent += `<span class="ghost-text-item">${GHOST_TEXT}</span>`;
                }
                ghostTextOverlay.innerHTML = htmlContent;
            }
        }


        /**
         * 右下の履歴リストを更新する
         */
        function updateHistoryList() {
            
            // 1. タブを生成する
            let tabsHtml = `<div class="flex justify-between mb-2 bg-black/70 p-1 rounded-t-xl">`;
            for (const [key, name] of Object.entries(allDifficulties)) {
                const isActive = key === currentHistoryView ? 'bg-red-700 text-white shadow-inner' : 'bg-red-500/80 text-white hover:bg-red-600';
                // event.stopPropagation() を追加して、タブクリックがゲームコンテナに伝播するのを防ぐ
                tabsHtml += `<button onclick="event.stopPropagation(); setCurrentHistoryView('${key}')" class="text-xs font-bold py-1 px-2 rounded-lg ${isActive} transition w-1/${Object.keys(allDifficulties).length} mx-0.5">${name}</button>`;
            }
            tabsHtml += `</div>`;


            // 2. 現在選択されている難易度の履歴リストを生成する
            const history = getScoreHistoryByDifficulty(currentHistoryView);
            const currentHighScore = localStorage.getItem(`highScore_${currentHistoryView}`);
            
            let listHtml = `<div class="p-4 bg-black/60 backdrop-blur-sm text-white rounded-b-xl shadow-2xl max-h-60 overflow-y-auto">
                                <h3 class="text-xl font-bold mb-2 border-b border-gray-600 pb-1">${allDifficulties[currentHistoryView]} の記録 (最新5件)</h3>
                                <ul class="space-y-1 text-base">`;
            
            if (history.length === 0) {
                listHtml += '<li class="text-gray-400">まだ記録がありません</li>';
            } else {
                history.forEach((score, index) => {
                    const rank = index + 1;
                    // ベストスコアは文字列として保存されているため、数値に変換して比較
                    const isBest = score === parseInt(currentHighScore);
                    
                    listHtml += `<li class="flex justify-between items-center py-1">
                                    <span class="font-medium text-gray-300">#${rank}</span>
                                    <span class="${isBest ? 'text-red-400 font-extrabold text-lg' : 'text-yellow-400'}">
                                        ${score} ms ${isBest ? ' (BEST)' : ''}
                                    </span>
                                 </li>`;
                });
            }
            
            listHtml += '</ul></div>';
            
            // #history-container にタブとコンテンツを挿入
            historyContainer.innerHTML = tabsHtml + listHtml; 

            // 履歴がある場合のみボタンを表示
            const hasAnyHistory = Object.keys(allDifficulties).some(key => getScoreHistoryByDifficulty(key).length > 0);

            if (!hasAnyHistory) {
                toggleButton.classList.add('hidden');
            } else {
                toggleButton.classList.remove('hidden');
                // 履歴がある場合は、ボタンの初期テキストを設定
                if (historyIsOpen) {
                    toggleButton.innerHTML = `記録を閉じる <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd" /></svg>`;
                } else {
                    toggleButton.innerHTML = `過去の記録 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>`;
                }
            }
        }

        /**
         * 統計情報を更新し、画面上部に表示する
         */
        function updateStats() {
            const highScoreDisplay = getHighScoreDisplay(); // 現在の難易度のベストを表示
            let statsHtml = '';
            // 成功した個別の3回分の記録
            // ペナルティタイムには (P) を付けて区別
            let history = reactionTimes.map((time, index) => {
                if (time >= TOTAL_FEINT_PENALTY) {
                    return `#${index + 1}: ${time}ms (P)`;
                }
                return `#${index + 1}: ${time}ms`;
            }).join(', ');

            const difficultyName = allDifficulties[currentDifficulty];

            if (gameState === 'home') {
                 statsHtml = `難易度: ${difficultyName} | ベスト: ${highScoreDisplay}`;
            } else if (attemptCount === maxAttempts) {
                // 最終結果の表示（スコア更新チェック済み）
                const total = reactionTimes.reduce((sum, time) => sum + time, 0);
                const average = Math.round(total / maxAttempts);
                
                // 新しい記録が保存されたかチェック
                const currentHighScoreKey = `highScore_${currentDifficulty}`;
                const isNewRecord = average <= parseInt(localStorage.getItem(currentHighScoreKey) || Infinity);
                
                const recordText = isNewRecord ? 
                    `<span class="text-red-300 font-extrabold text-2xl">✨ NEW RECORD! ${average} ms ✨</span>` : 
                    `<span class="text-yellow-300">平均: ${average} ms</span>`;
                
                statsHtml = `<div class="text-2xl">${recordText}</div>`;
                statsHtml += `<div class="text-sm mt-1">現在のベスト (${difficultyName}): ${highScoreDisplay} | 内訳: ${history}</div>`;

            } else {
                // 通常の進行中の表示
                statsHtml = `難易度: ${difficultyName} | 目標: ${maxAttempts}回の平均反応時間を計測 | 現在: ${attemptCount} / ${maxAttempts} 回 | ベスト: ${highScoreDisplay}`;
                if (reactionTimes.length > 0) {
                    statsHtml += `<div class="text-sm mt-1">前回の記録: ${history}</div>`;
                } else {
                     statsHtml = `難易度: ${difficultyName} | 目標: ${maxAttempts}回の平均反応時間を計測 | 現在: ${attemptCount} / ${maxAttempts} 回 | ベスト: ${highScoreDisplay}`;
                }
            }
            statsContainer.innerHTML = statsHtml;
        }

        /**
         * ゲームの状態に応じて画面を更新する
         * @param {string} state - 新しいゲームの状態
         * @param {string} message1 - メインメッセージ
         * @param {string} message2 - サブメッセージ
         * @param {string} colorClass - 背景色のTailwindクラス (例: 'blue-600') または直接のCSSカラー値
         */
        function updateScreen(state, message1, message2, colorClass) {
            gameState = state;
            mainMessage.textContent = message1;
            subMessage.textContent = message2;
            
            // レインボーアニメーションクラスを削除
            gameContainer.classList.remove('rainbow-mode');

            // colorClass が Tailwind の場合は bg- 接頭辞を付ける
            // カスタムCSS変数の場合はそのまま設定
            if (colorClass.startsWith('#')) {
                gameContainer.style.backgroundColor = colorClass;
                gameContainer.className = gameContainer.className.split(' ').filter(c => !c.startsWith('bg-')).join(' '); // Tailwindのbg-クラスを削除
            } else {
                gameContainer.style.backgroundColor = ''; // カスタムスタイルをリセット
                gameContainer.className = `bg-${colorClass} w-full h-full flex flex-col justify-center items-center cursor-pointer transition duration-400`;
            }
            
            // === NEW: ゴーストテキストオーバーレイの表示/非表示 ===
            if (state !== 'home' && state !== 'finished' && currentDifficulty === 'ghost') {
                ghostTextOverlay.classList.remove('hidden');
            } else {
                ghostTextOverlay.classList.add('hidden');
            }
            // ========================================================
            
            // ホーム画面の表示/非表示を切り替える
            if (state === 'home') { // 'home' のみ homeScreen を表示
                homeScreen.classList.remove('hidden');
                mainMessage.classList.add('hidden');
                subMessage.classList.add('hidden');
                document.getElementById('start-button').textContent = '開始'; 
            } else {
                homeScreen.classList.add('hidden');
                mainMessage.classList.remove('hidden');
                subMessage.classList.remove('hidden');
            }

            mainMessage.classList.add('text-center');
            subMessage.classList.add('text-center');

            if (state === 'go') {
                mainMessage.classList.remove('text-5xl', 'md:text-7xl');
                mainMessage.classList.add('text-8xl', 'md:text-9xl');
            } else {
                mainMessage.classList.remove('text-8xl', 'md:text-9xl');
                mainMessage.classList.add('text-5xl', 'md:text-7xl');
            }
            
            // 画面更新時に統計情報と履歴リストも更新
            updateStats();
            updateHistoryList();
        }

        /**
         * 画面を「GO!」の色に切り替え、時間を記録する
         */
        function changeColorToGo() {
            // GOサインが出た場合、プレアラート/レインボー/パーティーのタイマーと要素をクリア
            if (preAlertTimeoutId) {
                clearTimeout(preAlertTimeoutId);
                preAlertTimeoutId = null;
            }
            if (rainbowTimeoutId) {
                clearTimeout(rainbowTimeoutId);
                rainbowTimeoutId = null;
                gameContainer.classList.remove('rainbow-mode'); // レインボー解除
            }
            if (partyTimeoutId) { // NEW: パーティータイマーもクリア
                clearTimeout(partyTimeoutId);
                partyTimeoutId = null;
                partyElements.forEach(el => el.remove());
                partyElements = [];
            }

            // ナイトメア/ゴーストモードは特殊な色、それ以外は普通の緑
            let goColor = 'green-500';

            if (currentDifficulty === 'nightmare') {
                goColor = 'var(--nightmare-go-color)';
            } else if (currentDifficulty === 'ghost') { // NEW: ゴーストモードのランダム化
                // 完全にランダムな色を生成
                goColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            }

            updateScreen(
                'go', 
                'クリック！', 
                (currentDifficulty === 'ghost') ? 'ルールは存在しない。ただひたすら待て...' : '今すぐクリック！', 
                goColor // クリックするべき合図の色
            );
            // 色が変わった瞬間のタイムスタンプを記録
            startTime = performance.now();
        }

        /**
         * フェイント表示後に待機状態に戻り、改めてGOのタイマーをセットする
         */
        function returnToWaiting() {
             // ユーザーがフェイント中にクリックしなかった場合のみ実行
            if (gameState === 'feint') {
                // 待機状態に戻り、改めてGOのタイマーをセット (再帰的に startGame を呼び出す)
                startGame();
            }
        }

        /**
         * 画面を「フェイント！」の色に切り替える
         */
        function changeColorToFeint() {
            // GOサインが出た場合、プレアラート/レインボー/パーティーのタイマーと要素をクリア
            if (preAlertTimeoutId) {
                clearTimeout(preAlertTimeoutId);
                preAlertTimeoutId = null;
            }
            if (rainbowTimeoutId) {
                clearTimeout(rainbowTimeoutId);
                rainbowTimeoutId = null;
                gameContainer.classList.remove('rainbow-mode'); // レインボー解除
            }
            if (partyTimeoutId) { // NEW: パーティータイマーもクリア
                clearTimeout(partyTimeoutId);
                partyTimeoutId = null;
                partyElements.forEach(el => el.remove());
                partyElements = [];
            }

            // ナイトメア/ゴーストモードは黄色、それ以外は赤
            let feintColor = 'red-700';

            if (currentDifficulty === 'nightmare') {
                feintColor = 'yellow-500';
            } else if (currentDifficulty === 'ghost') { // NEW: ゴーストモードのランダム化
                // 完全にランダムな色を生成
                feintColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            }

            updateScreen(
                'feint', 
                'ストップ！', 
                (currentDifficulty === 'ghost') ? '無意味な衝動。次を待て...' : 'クリックしてはいけません (フェイント)',
                feintColor // フェイントを示す色
            );
            
            // 短時間後（例：1秒後）に自動的に青色の待機状態に戻り、次のGOの準備をする
            const returnDuration = 1000;
            timeoutId = setTimeout(returnToWaiting, returnDuration);
        }

        /**
         * 難易度「簡単」の場合、2秒後に警告メッセージを表示する
         */
        function showPreAlert() {
            // 現在のゲーム状態が 'waiting' または 'pre-alert' の場合のみ実行
            if (gameState === 'waiting' || gameState === 'pre-alert') {
                gameState = 'pre-alert'; // 状態を 'pre-alert' に設定
                subMessage.textContent = '3秒間以内に表示されるから準備して！'; 
                // 背景色を黄色に切り替える
                updateScreen(gameState, mainMessage.textContent, subMessage.textContent, 'yellow-500');
            }
        }

        /**
         * レインボー効果を開始し、指定時間後に停止して通常の待機に戻る
         */
        function startRainbowEffect(durationMs, continueGameCallback) {
            // 既存のタイマーをクリア
            if (timeoutId) clearTimeout(timeoutId);
            if (preAlertTimeoutId) clearTimeout(preAlertTimeoutId);
            if (rainbowTimeoutId) clearTimeout(rainbowTimeoutId);
            if (partyTimeoutId) clearTimeout(partyTimeoutId); // パーティータイマーもクリア

            // レインボー中はゲームの論理的状態は 'waiting' のまま維持
            mainMessage.textContent = '集中して！';
            subMessage.textContent = '何かが起こるかもしれません...';
            gameContainer.classList.add('rainbow-mode'); // レインボーアニメーションを適用
            gameContainer.style.backgroundColor = ''; // Tailwindのbg-クラスを削除してCSSアニメーションを有効にする

            rainbowTimeoutId = setTimeout(() => {
                gameContainer.classList.remove('rainbow-mode'); // レインボーアニメーションを停止
                gameContainer.className = `bg-blue-600 w-full h-full flex flex-col justify-center items-center cursor-pointer transition duration-400`; // 背景を青に戻す
                // 通常の待機状態に戻り、ゲームを続行
                continueGameCallback(); 
            }, durationMs);
        }

        /**
         * パーティー効果を開始し、指定時間後に停止して通常の待機に戻る
         */
        function startPartyEffect(durationMs, continueGameCallback) {
            // 既存のタイマーをクリア
            if (timeoutId) clearTimeout(timeoutId);
            if (preAlertTimeoutId) clearTimeout(preAlertTimeoutId);
            if (rainbowTimeoutId) clearTimeout(rainbowTimeoutId);
            if (partyTimeoutId) clearTimeout(partyTimeoutId);

            // パーティー中はゲームの論理的状態は 'waiting' のまま維持
            mainMessage.textContent = 'ノリノリだぜ！';
            subMessage.textContent = '気を散らさないように！';
            
            // テキスト要素を生成・アニメーションさせる
            const textToFlow = "うぇーいｗｗｗ";
            const elementCount = 5; 
            
            for (let i = 0; i < elementCount; i++) {
                const textElement = document.createElement('div');
                textElement.textContent = textToFlow;
                textElement.className = 'party-text absolute whitespace-nowrap';
                
                // ランダムな位置とアニメーション時間
                const randomX = Math.random() * 80;
                const randomY = Math.random() * 80;
                const randomDelay = Math.random() * 0.5;
                const randomDuration = Math.random() * 4 + 3; // 3s to 7s duration

                textElement.style.left = `${randomX}vw`;
                textElement.style.top = `${randomY}vh`;
                textElement.style.color = `hsl(${Math.random() * 360}, 100%, 70%)`; // ランダムな色
                textElement.style.opacity = Math.random() * 0.3 + 0.1; // 10% - 40% opacity
                
                // アニメーションの設定を上書き
                textElement.style.animation = `flow-in ${randomDuration}s ease-in-out ${randomDelay}s infinite alternate`;
                
                gameContainer.appendChild(textElement);
                partyElements.push(textElement);
            }
            
            partyTimeoutId = setTimeout(() => {
                // テキスト要素を全て削除
                partyElements.forEach(el => el.remove());
                partyElements = [];
                // ゲームを続行
                continueGameCallback(); 
            }, durationMs);
        }

        /**
         * ゲームを開始（待機状態へ移行）する
         */
        function startGame() {
             // 3回完了後のリセット処理
            if (attemptCount === maxAttempts) {
                reactionTimes = [];
                attemptCount = 0;
            }
            
            // 前回のタイマーをクリア
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            if (preAlertTimeoutId) {
                clearTimeout(preAlertTimeoutId);
            }
            if (rainbowTimeoutId) { // レインボータイマーもクリア
                clearTimeout(rainbowTimeoutId);
                rainbowTimeoutId = null;
                gameContainer.classList.remove('rainbow-mode'); // レインボーを停止
            }
            if (partyTimeoutId) { // NEW: パーティータイマーもクリア
                clearTimeout(partyTimeoutId);
                partyTimeoutId = null;
                partyElements.forEach(el => el.remove());
                partyElements = [];
            }
            
            const settings = difficultySettings[currentDifficulty];
            
            // GOサインまでのランダムな遅延時間
            const randomDelay = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min;

            // 通常の待機中状態に移行 (先に画面を青に戻しておく)
            updateScreen(
                'waiting', 
                '準備中...', 
                `緑に変わったらすぐにクリック！ (${attemptCount + 1}回目)`, 
                'blue-600'
            );


            // ナイトメア/ゴーストモードで集中力妨害効果を発生させるか判定
            if (currentDifficulty === 'nightmare' || currentDifficulty === 'ghost') {
                // ゴーストモードでは妨害効果なし
                if (currentDifficulty === 'ghost') {
                    // 何もしない (純粋な待ち時間のみ)
                } else {
                    // ナイトメアモードの妨害効果の判定
                    const isRainbow = settings.rainbowChance > 0 && Math.random() < settings.rainbowChance;
                    const isParty = !isRainbow && settings.partyChance > 0 && Math.random() < settings.partyChance; 
                    
                    if (isRainbow) {
                        const rainbowDuration = Math.floor(Math.random() * 2000) + 2000;
                        startRainbowEffect(rainbowDuration, () => {
                            setGoOrFeintTimer(randomDelay, settings);
                        });
                        return; // 処理終了
                    } else if (isParty) { // NEW: パーティー効果
                        const partyDuration = Math.floor(Math.random() * 2000) + 2000;
                        startPartyEffect(partyDuration, () => {
                            setGoOrFeintTimer(randomDelay, settings);
                        });
                        return; // 処理終了
                    }
                }
            }

            // 難易度「簡単」の場合、2秒後に準備メッセージを表示
            if (currentDifficulty === 'easy' && randomDelay > 2000) {
                 preAlertTimeoutId = setTimeout(showPreAlert, 2000);
            }

            setGoOrFeintTimer(randomDelay, settings);
        }
        
        /**
         * GOサインまたはフェイントのタイマーを設定するヘルパー関数
         * @param {number} delay - GOサインまでの遅延時間
         * @param {object} settings - 現在の難易度設定
         */
        function setGoOrFeintTimer(delay, settings) {
            // 難易度が 'hard', 'normal', 'nightmare', 'ghost' で、かつランダムな確率でフェイントを発生させる
            if (settings.feintChance > 0 && Math.random() < settings.feintChance) {
                // フェイントを発生させる: ランダム遅延時間よりも短い時間で赤に変わる
                const feintDuration = Math.floor(Math.random() * (settings.min / 2)) + 500; // 0.5秒〜最小遅延の半分まで
                timeoutId = setTimeout(changeColorToFeint, feintDuration);
            } else {
                // 通常のGOを発生させる
                timeoutId = setTimeout(changeColorToGo, delay);
            }
        }


        /**
         * ホーム画面の開始ボタンが押されたときの処理
         */
        function handleStartClick() {
            if (gameState === 'home' || gameState === 'finished') {
                // 50ms の遅延を設けて、ボタンのクリックイベントが完全に終了するのを待つ (バグ修正)
                setTimeout(startGame, 50); 
            }
        }

        /**
         * マウスのクリックイベントを処理するメイン関数
         */
        function handleMouseClick() {
            
            // === [履歴が開いている場合のクリック処理] ===
            // 履歴が開いている場合は、背景クリックを「履歴を閉じる」操作として扱う
            if (historyIsOpen) {
                toggleHistory();
                return; // ゲーム開始処理をスキップ
            }
            // ============================================

            const now = performance.now();

            switch (gameState) {
                case 'home':
                    // ホーム画面ではボタンクリックのみを有効とする
                    break;
                case 'finished':
                    // **変更点**: 3回完了後の最終結果画面でのクリック時のみホーム画面に戻る
                    if (reactionTimes.length === maxAttempts) {
                        // 最終結果画面の場合、次のクリックでホーム画面に戻る
                        reactionTimes = []; // 配列をリセット
                        attemptCount = 0;   // カウントをリセット
                        updateScreen('home', '', '', 'blue-600');
                    } else {
                        // 3回完了前の中間結果、フライング、またはペナルティの場合、次の試行を開始
                        startGame(); 
                    }
                    break;

                case 'waiting':
                case 'pre-alert': // pre-alert 状態もwaitingと同じ扱い
                case 'rainbow': // レインボー中もフライングとして扱う
                case 'party': // NEW: パーティー中もフライングとして扱う
                    // 色が変わる前にクリックした（フライング）
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    if (preAlertTimeoutId) {
                        clearTimeout(preAlertTimeoutId);
                        preAlertTimeoutId = null;
                    }
                    if (rainbowTimeoutId) { 
                        clearTimeout(rainbowTimeoutId);
                        rainbowTimeoutId = null;
                        gameContainer.classList.remove('rainbow-mode'); 
                    }
                    if (partyTimeoutId) { // NEW: パーティータイマーもクリア
                        clearTimeout(partyTimeoutId);
                        partyTimeoutId = null;
                        partyElements.forEach(el => el.remove());
                        partyElements = [];
                    }

                    updateScreen(
                        'finished', 
                        '早すぎます！', 
                        'もう一度挑戦するにはクリック', // メッセージ修正
                        'red-600' // エラーを示す色
                    );
                    break;
                
                case 'feint': 
                    // フェイント中にクリックした場合 (不正解/ペナルティ適用)
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    if (preAlertTimeoutId) {
                        clearTimeout(preAlertTimeoutId);
                        preAlertTimeoutId = null;
                    }
                    if (rainbowTimeoutId) { // レインボータイマーもクリア
                        clearTimeout(rainbowTimeoutId);
                        rainbowTimeoutId = null;
                        gameContainer.classList.remove('rainbow-mode'); // レインボーを停止
                    }
                    if (partyTimeoutId) { // NEW: パーティータイマーもクリア
                        clearTimeout(partyTimeoutId);
                        partyTimeoutId = null;
                        partyElements.forEach(el => el.remove());
                        partyElements = [];
                    }
                    
                    // === [ペナルティの記録と試行回数のインクリメント] ===
                    const penaltyTime = TOTAL_FEINT_PENALTY;
                    reactionTimes.push(penaltyTime); // ペナルティタイムを記録
                    attemptCount++; 

                    if (attemptCount === maxAttempts) {
                        // 3回完了！平均を計算して表示
                        const total = reactionTimes.reduce((sum, time) => sum + time, 0);
                        const average = Math.round(total / maxAttempts);
                        
                        // 最終平均メッセージの判定
                        let averageMessage = '';

                        if (currentDifficulty === 'ghost' && average <= GHOST_EXCELLENT_MAX) {
                            // ゴーストモードで 300ms 以下の場合の特別メッセージ (最優先)
                            averageMessage = ` (あなたは限界に挑戦しましたね…お疲れ様です（そんな時間あるなら用事終わらせろよ）)`;
                        } else if (average <= AVERAGE_PRO_MAX) { // 249ms 以下
                            averageMessage = ` (プロゲーマーの域将来有望)`;
                        } else if (average >= AVERAGE_GOOD_MIN && average <= AVERAGE_GOOD_MAX) { // 250ms～299ms
                            averageMessage = ` (いいほうだよ！)`;
                        } else if (average >= AVERAGE_NORMAL_MIN && average <= AVERAGE_NORMAL_MAX) { // 300ms～400ms
                            averageMessage = ` (普通だね)`;
                        } else if (average >= AVERAGE_WORST_MIN) { // 401ms 以上
                            averageMessage = ` (クソあほぼけなすカスｗｗよっわあああｗｗｗおっそすぎるえぐい)`;
                        }

                        // ベストスコアの更新
                        const currentHighScoreKey = `highScore_${currentDifficulty}`;
                        const currentHighScore = localStorage.getItem(currentHighScoreKey);
                        if (!currentHighScore || average < parseInt(currentHighScore)) {
                            localStorage.setItem(currentHighScoreKey, average.toString());
                        }
                        // 履歴リストに追加
                        addScoreToHistory(average);
                        
                        updateScreen(
                            'finished', 
                            `${average} ms`, 
                            `最終平均 (${maxAttempts}回)です${averageMessage}。クリックしてホーム画面へ`, // メッセージ修正
                            'purple-600' // 最終結果の色
                        );
                        console.log(`全${maxAttempts}回の平均反応時間: ${average} ms`);
                    } else {
                        // 3回未満の場合、ペナルティの結果と次の指示を表示
                        updateScreen(
                            'finished', 
                            `ペナルティ: ${penaltyTime} ms`, 
                            `ざんねんＷ！次の回へ進みます。クリックして次へ`, // メッセージ修正
                            'red-600' 
                        );
                        console.log(`試行 ${attemptCount} 回目 (ペナルティ): ${penaltyTime} ms`);
                    }
                    // ===============================================
                    break;

                case 'go':
                    // 正しいタイミングでクリック -> 反応時間を計算
                    const reactionTime = Math.round(now - startTime);
                    reactionTimes.push(reactionTime); // 結果を配列に追加
                    attemptCount++; // 成功したクリックのみ試行回数をインクリメント

                    // === [煽りメッセージの判定ロジック] ===
                    let tauntMessage = '';
                    if (reactionTime >= TAUNT_THRESHOLD_MS) { // 350ms以上
                        tauntMessage = ` (おそいねぇｗ)`;
                    } else if (reactionTime >= OKAY_THRESHOLD_MS) { // 300ms～349ms
                        tauntMessage = ` (まぁ次は頑張ろう)`;
                    } else if (reactionTime >= EXCELLENT_THRESHOLD_MS) { // 200ms～299ms
                        tauntMessage = ` (結構いい！)`;
                    } else { // 200ms未満
                        tauntMessage = ` (えぐすぎる！)`;
                    }
                    // =====================================

                    if (attemptCount === maxAttempts) {
                        // 3回完了！平均を計算して表示
                        const total = reactionTimes.reduce((sum, time) => sum + time, 0);
                        const average = Math.round(total / maxAttempts);
                        
                        // 最終平均メッセージの判定
                        let averageMessage = '';
                        
                        if (currentDifficulty === 'ghost' && average <= GHOST_EXCELLENT_MAX) {
                            // ゴーストモードで 300ms 以下の場合の特別メッセージ (最優先)
                            averageMessage = ` (あなたは限界に挑戦しましたね…お疲れ様です（そんな時間あるなら用事終わらせろよ）)`;
                        } else if (average <= AVERAGE_PRO_MAX) { // 249ms 以下
                            averageMessage = ` (プロゲーマーの域将来有望)`;
                        } else if (average >= AVERAGE_GOOD_MIN && average <= AVERAGE_GOOD_MAX) { // 250ms～299ms
                            averageMessage = ` (いいほうだよ！)`;
                        } else if (average >= AVERAGE_NORMAL_MIN && average <= AVERAGE_NORMAL_MAX) { // 300ms～400ms
                            averageMessage = ` (普通だね)`;
                        } else if (average >= AVERAGE_WORST_MIN) { // 401ms 以上
                            averageMessage = ` (クソあほぼけなすカスｗｗよっわあああｗｗｗおっそすぎるえぐい)`;
                        }


                        // ベストスコアの更新
                        const currentHighScoreKey = `highScore_${currentDifficulty}`;
                        const currentHighScore = localStorage.getItem(currentHighScoreKey);
                        if (!currentHighScore || average < parseInt(currentHighScore)) {
                            localStorage.setItem(currentHighScoreKey, average.toString());
                        }
                        // 履歴リストに追加
                        addScoreToHistory(average);
                        
                        updateScreen(
                            'finished', 
                            `${average} ms`, 
                            `最終平均 (${maxAttempts}回)です${averageMessage}。クリックしてホーム画面へ`, // メッセージ修正
                            'purple-600' // 最終結果の色
                        );
                        console.log(`全${maxAttempts}回の平均反応時間: ${average} ms`);

                    } else {
                        // 3回未満の場合、現在の結果と次の指示を表示
                        updateScreen(
                            'finished', 
                            `${reactionTime} ms`, 
                            `現在の記録です${tauntMessage}。あと ${maxAttempts - attemptCount} 回！クリックして次へ`, // メッセージ修正
                            'orange-500' // 中間結果の色
                        );
                        console.log(`試行 ${attemptCount} 回目の反応時間: ${reactionTime} ms`);
                    }
                    break;
            }
        }

        /**
         * 以前の単一キーのスコアを「普通」モードに移行する
         */
        function migrateOldScores() {
            const oldHistoryJson = localStorage.getItem('scoreHistory');
            const oldHighScore = localStorage.getItem('highScore');

            if (oldHistoryJson) {
                // 古い履歴スコアを 'normal' のキーで保存
                localStorage.setItem('scoreHistory_normal', oldHistoryJson);
                localStorage.removeItem('scoreHistory');
                console.log("古い履歴スコアを 'normal' に移行しました。");
            }
             if (oldHighScore) {
                // 古いベストスコアを 'normal' のキーで保存
                localStorage.setItem('highScore_normal', oldHighScore);
                localStorage.removeItem('highScore');
                console.log("古いベストスコアを 'normal' に移行しました。");
            }
        }

        // ページロード時の初期設定
        window.onload = function() {
            // スコア移行チェック
            migrateOldScores();

            // ゴーストオーバーレイのテキストを初期化
            initializeGhostOverlay();

            // ドロップダウンの初期値を読み込んで難易度を設定
            setDifficulty(difficultySelect.value);
            currentHistoryView = difficultySelect.value; // 初期表示難易度を現在の難易度に合わせる

            // 初回ロード時に履歴リストを更新
            updateHistoryList();
            
            // 履歴は初期状態で閉じておく
            historyIsOpen = false;
            // historyContainerを閉じている状態にしておく
            historyContainer.classList.add('translate-x-full');

            updateScreen(
                'home', 
                '', 
                '', 
                'blue-600' // ホーム画面は常に青背景
            );
        };
    </script>
</body>
</html>